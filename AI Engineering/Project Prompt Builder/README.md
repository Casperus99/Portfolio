# üöÄ Project Context Generator for LLMs

## An AI-Assisted Development Showcase

This repository presents a robust and extensible Python utility designed to automatically generate structured project context for Large Language Models (LLMs) like Google Gemini. By transforming a local Python codebase into a highly organized, AI-digestible prompt, this tool significantly enhances the LLM's ability to understand, analyze, and assist with complex software projects.

### ‚ú® Key Features:

*   **Automated Project Scan:** Recursively scans a specified Python project directory to identify all relevant source files.
*   **Structured Directory Tree:** Generates a clean, visual representation of the project's file and folder hierarchy (excluding irrelevant directories like `__pycache__`).
*   **Formatted Source Code Inclusion:** Embeds the content of all Python files, clearly labeled with their relative paths, within a structured Markdown format.
*   **Customizable Prompt Templates:** Utilizes user-defined Markdown templates to construct the final prompt, allowing for flexible introductory messages and section ordering.
*   **Modular & Extensible Design:** Built with adherence to modern OOP principles (SRP, Loose Coupling, Encapsulation) for easy maintenance, testing, and future expansion.

---

### üí° The Problem This Project Solves:

When engaging LLMs for code analysis, refactoring, or debugging, providing the model with a comprehensive understanding of the entire project context (not just isolated code snippets) is paramount. Manually compiling file structures and source code is tedious and error-prone. This tool automates that process, ensuring the AI receives a complete and consistent project overview every time.

---

### üì¶ Project Structure:

The repository is organized for clarity and ease of use:

```
.
‚îú‚îÄ‚îÄ main.py                     # The main entry point for running the tool.
‚îú‚îÄ‚îÄ input_prompts/              # Contains customizable prompt templates.
‚îÇ   ‚îî‚îÄ‚îÄ full_prompt_template.md # The primary template for the generated prompt.
‚îÇ   ‚îî‚îÄ‚îÄ system_prompt.md        # (Optional) Place your system prompt template here.
‚îî‚îÄ‚îÄ output_prompts/             # Where the generated final prompt is saved.
    ‚îî‚îÄ‚îÄ final_prompt.md         # The complete prompt generated by the tool.
‚îî‚îÄ‚îÄ project_prompt_builder/     # The core Python package with generation logic.
    ‚îú‚îÄ‚îÄ __init__.py             # Package initialization and facade function.
    ‚îú‚îÄ‚îÄ project_manager.py      # Handles file system interactions.
    ‚îú‚îÄ‚îÄ prompt_formatter.py     # Formats content into AI-readable sections.
    ‚îî‚îÄ‚îÄ prompt_generator.py     # Orchestrates prompt assembly.
```

*   **`input_prompts/`**: This directory is where you place your static prompt templates. `full_prompt_template.md` is crucial; it defines the overall structure of your prompt and contains the `{{PROJECT_CONTEXT}}` placeholder where the dynamic project data (tree and code) will be injected. You can also store your `system_prompt.md` here for easy access, although the tool does not directly interact with it.
*   **`output_prompts/`**: The `final_prompt.md` file in this directory is the ultimate output of the tool. It contains the complete, structured prompt that you can copy-paste directly into your LLM interface.

---

### üõ†Ô∏è Getting Started:

1.  **Clone the repository:**
    ```bash
    git clone [your-repo-link]
    cd [your-repo-name]
    ```
2.  **Configure your project path:**
    Open `main.py` and update the `PROJECT_ROOT_PATH` variable with the absolute path to the Python project you wish to analyze.
    ```python
    # main.py
    PROJECT_ROOT_PATH = "/path/to/your/actual/python/project"
    ```
3.  **Run the tool:**
    ```bash
    python main.py
    ```
    On the first run, `input_prompts/full_prompt_template.md` will be created with a default structure if it doesn't exist.
4.  **Access the generated prompt:**
    Your comprehensive prompt will be saved in `output_prompts/final_prompt.md`.

---

### ü§ù AI-Driven Development: A Case Study in Collaborative Engineering

This project is a compelling example of modern software development, born entirely from an iterative and highly effective collaboration between a human (the repository owner) and a **Senior AI Software Architect and Development Partner** (the AI that generated this code).

The development journey unfolded through a series of focused, requirement-driven iterations:

*   **Initial Concept:** The process began with a precise request to convert Python project files into a formatted prompt for Google Gemini.
*   **Feature Expansion:** Requirements rapidly evolved, incorporating file-based output, the generation of recursive directory structures, and refinement of visual output formats (e.g., `‚îú‚îÄ‚îÄ`, `‚îî‚îÄ‚îÄ`).
*   **Architectural Refinement:** Crucially, the process included a deliberate refactoring phase, transforming the initial script into a modular Python package (`project_prompt_builder`). This phase focused on rigorous adherence to OOP principles:
    *   **Single Responsibility Principle (SRP):** Each class (`ProjectManager`, `PromptFormatter`, `PromptGenerator`) was meticulously crafted with a single, well-defined role.
    *   **Loose Coupling & Encapsulation:** Components were designed to be independent and communicate via clear interfaces, ensuring maintainability and testability.
    *   **Extensibility:** The architecture inherently supports future additions, such as new file types or output formats, with minimal impact on existing code.
*   **Simplified Interface (Facade Pattern):** The final step involved abstracting the package's internal complexity behind a simple, intuitive function, `build_project_prompt`, making the tool easy to integrate and use.

This project not only delivers a valuable utility but also serves as a living testament to the power of clear communication, iterative problem-solving, and disciplined software engineering principles when collaborating with advanced AI. It demonstrates an ability to translate abstract needs into robust, maintainable, and well-documented solutions.

---

### üõ£Ô∏è Future Enhancements:

*   Support for additional programming languages and file types.
*   Option to include `requirements.txt` or configuration files.
*   Integration with AI APIs for direct prompt submission.

---